<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/blog/_next/static/css/d34310680f0ae524e008.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/d34310680f0ae524e008.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/blog/_next/static/chunks/webpack-3297a19f96a66183618c.js" defer=""></script><script src="/blog/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/blog/_next/static/chunks/main-7965b115b2b3050da998.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-d7a37d6a79167d5905aa.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-911dd671514f45cf855f.js" defer=""></script><script src="/blog/_next/static/dKE0yQw6eLsE4LvwLl6j4/_buildManifest.js" defer=""></script><script src="/blog/_next/static/dKE0yQw6eLsE4LvwLl6j4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="h-full flex flex-col"><div class="sticky top-0 shadow-md bg-gray-800 text-white"><div class="container mx-auto md:px-52 px-10"><header><div class="flex py-1.5 items-center"><a class="mr-auto hover:bg-gray-700 hover:no-underline p-3 hover:text-white py-1.5 rounded transition duration-200" href="/blog"><h1 class="text-2xl mb-0">Douglas Greyling</h1></a><a class="button" href="/blog/posts">All Posts</a></div></header></div></div><main class="bg-gray-100 pt-10 flex-auto"><div class="container mx-auto md:px-52 px-10 overflow-hidden"><div><h1>Communication Between Angular Components</h1><h2 class="text-gray-400 font-extralight mb-5 text-lg">June 29 2020</h2><div><p>I thought I could go through how to hook Angular components to each other so they can listen to each other listen for specific events. Angular components are able to receive a set of inputs, by decorating properties of the class with the <code>@Input</code> decorator, likewise we can set the outputs of a particular component using the <code>@Output</code> decorator.</p>
<p>Let’s imagine we’re making a simple party app where we have two components in our app. The one has a button, which when clicked emits a party event. When this event is raised, our second component needs to flash the appropriate message, so we all know what to do.</p>
<p>The one component (let’s call it our <code>PartyButtonComponent</code>) is the component which displays the appropriate button. It needs to raise an event, when the button is clicked.
Its controller will look like this:</p>
<pre><code class="language-javascript">import { Component, Output, EventEmitter } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;party-button&#39;,
  templateUrl: &#39;./party-button.component.html&#39;,
  styleUrls: [&#39;./party-button.component.css&#39;]
})
export class PartyButtonComponent  {
  @Output() onParty: EventEmitter&lt;null&gt; = new EventEmitter&lt;null&gt;();

  party() {
    this.onParty.emit();
  }
}
</code></pre>
<p>And its template will look something like this:</p>
<pre><code class="language-html">&lt;button class=&quot;btn btn-success&quot; type=&quot;button&quot; (click)=&quot;party()&quot;&gt;Party!&lt;/button&gt;
</code></pre>
<p>Here we’ve created our party button component. We’ve created an <code>onParty</code> output, which uses an Angular Event Emitter so that Angular can pick up on our events and initiate change detection.</p>
<p>The button in our template will emit the <code>onParty</code> event, when the <code>party</code> method is called by clicking the button.</p>
<p>Now, in order for our second component (which we’ll call the <code>PartyTextComponent</code>) to detect this event, it needs to listen to the <code>PartyButtonComponent</code>’s <code>onParty</code> event. We can do this like so:</p>
<pre><code class="language-html">&lt;party-button (onParty)=&quot;text.showPartyText()&quot;&gt;&lt;/party-button&gt;
&lt;party-text #text&gt;&lt;/party-text&gt;
</code></pre>
<p>Here we’ve defined our <code>PartyButtonComponent</code> and our <code>PartyTextComponent</code>. We’ve then defined a template variable called <code>text</code>, this creates a reference to <code>PartyTextComponent</code> which we can then use to call its <code>showPartyText()</code> method when the <code>onParty()</code> event is emitted from our <code>PartyButtonComponent</code>.</p>
<pre><code class="language-javascript">import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;party-text&#39;,
  templateUrl: &#39;./party-text.component.html&#39;,
  styleUrls: [&#39;./party-text.component.css&#39;]
})
export class PartyTextComponent  {
  private showText: Boolean = false;

  showPartyText () {
    this.showText = !this.showText;
  }
}
</code></pre>
<p>Here our <code>PartyTextComponent</code> is just keeping track of some state which will control whether, or not, the party text should be displayed. I’ll omit the template for this component since a simple directive is all you need to get this working.</p>
<p>But that’s essentially it. This is a great way to allow components to listen to each other. The downside to this approach is that this method only allows us to have components communicate with each other in the template using template variables.</p>
<p>There is a way to bring this code into the controllers of our components, but I’ll leave that for another blog.</p>
</div></div><div class="flex justify-center pt-10 pb-20"><a class="button" href="/blog/posts"><h4>Read more posts</h4></a></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"id":11,"title":"Communication Between Angular Components","date":"June 29 2020"},"slug":"communication-between-angular-components","content":"\u003cp\u003eI thought I could go through how to hook Angular components to each other so they can listen to each other listen for specific events. Angular components are able to receive a set of inputs, by decorating properties of the class with the \u003ccode\u003e@Input\u003c/code\u003e decorator, likewise we can set the outputs of a particular component using the \u003ccode\u003e@Output\u003c/code\u003e decorator.\u003c/p\u003e\n\u003cp\u003eLet’s imagine we’re making a simple party app where we have two components in our app. The one has a button, which when clicked emits a party event. When this event is raised, our second component needs to flash the appropriate message, so we all know what to do.\u003c/p\u003e\n\u003cp\u003eThe one component (let’s call it our \u003ccode\u003ePartyButtonComponent\u003c/code\u003e) is the component which displays the appropriate button. It needs to raise an event, when the button is clicked.\nIts controller will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport { Component, Output, EventEmitter } from \u0026#39;@angular/core\u0026#39;;\n\n@Component({\n  selector: \u0026#39;party-button\u0026#39;,\n  templateUrl: \u0026#39;./party-button.component.html\u0026#39;,\n  styleUrls: [\u0026#39;./party-button.component.css\u0026#39;]\n})\nexport class PartyButtonComponent  {\n  @Output() onParty: EventEmitter\u0026lt;null\u0026gt; = new EventEmitter\u0026lt;null\u0026gt;();\n\n  party() {\n    this.onParty.emit();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd its template will look something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;button class=\u0026quot;btn btn-success\u0026quot; type=\u0026quot;button\u0026quot; (click)=\u0026quot;party()\u0026quot;\u0026gt;Party!\u0026lt;/button\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we’ve created our party button component. We’ve created an \u003ccode\u003eonParty\u003c/code\u003e output, which uses an Angular Event Emitter so that Angular can pick up on our events and initiate change detection.\u003c/p\u003e\n\u003cp\u003eThe button in our template will emit the \u003ccode\u003eonParty\u003c/code\u003e event, when the \u003ccode\u003eparty\u003c/code\u003e method is called by clicking the button.\u003c/p\u003e\n\u003cp\u003eNow, in order for our second component (which we’ll call the \u003ccode\u003ePartyTextComponent\u003c/code\u003e) to detect this event, it needs to listen to the \u003ccode\u003ePartyButtonComponent\u003c/code\u003e’s \u003ccode\u003eonParty\u003c/code\u003e event. We can do this like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;party-button (onParty)=\u0026quot;text.showPartyText()\u0026quot;\u0026gt;\u0026lt;/party-button\u0026gt;\n\u0026lt;party-text #text\u0026gt;\u0026lt;/party-text\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we’ve defined our \u003ccode\u003ePartyButtonComponent\u003c/code\u003e and our \u003ccode\u003ePartyTextComponent\u003c/code\u003e. We’ve then defined a template variable called \u003ccode\u003etext\u003c/code\u003e, this creates a reference to \u003ccode\u003ePartyTextComponent\u003c/code\u003e which we can then use to call its \u003ccode\u003eshowPartyText()\u003c/code\u003e method when the \u003ccode\u003eonParty()\u003c/code\u003e event is emitted from our \u003ccode\u003ePartyButtonComponent\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport { Component } from \u0026#39;@angular/core\u0026#39;;\n\n@Component({\n  selector: \u0026#39;party-text\u0026#39;,\n  templateUrl: \u0026#39;./party-text.component.html\u0026#39;,\n  styleUrls: [\u0026#39;./party-text.component.css\u0026#39;]\n})\nexport class PartyTextComponent  {\n  private showText: Boolean = false;\n\n  showPartyText () {\n    this.showText = !this.showText;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere our \u003ccode\u003ePartyTextComponent\u003c/code\u003e is just keeping track of some state which will control whether, or not, the party text should be displayed. I’ll omit the template for this component since a simple directive is all you need to get this working.\u003c/p\u003e\n\u003cp\u003eBut that’s essentially it. This is a great way to allow components to listen to each other. The downside to this approach is that this method only allows us to have components communicate with each other in the template using template variables.\u003c/p\u003e\n\u003cp\u003eThere is a way to bring this code into the controllers of our components, but I’ll leave that for another blog.\u003c/p\u003e\n"},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"communication-between-angular-components"},"buildId":"dKE0yQw6eLsE4LvwLl6j4","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>